# -*- coding: utf-8 -*-
"""예비 반려인을 위한 성격 별 반려견 종 추천 서비스 .ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1x_he6I-b70Fnh19FNowvsMWf7Yz-cx5s

## 예비 반려인을 위한 성격 별 반려견 종 추천 서비스
### → 당신의 DBTI는 무엇인가요?
"""

import os
import sys
import urllib.request
import pandas as pd
import json
import re

# 네이버 API 인증 정보: client_id와 client_secret
client_id = "MNVnjgnpKVPQ_5jxPkbN"
client_secret = "xcWuWkcN16"

# 한국에서 유명한 16가지 개 품종 리스트
dog_list = ['진돗개', '말티즈', '시츄', '치와와', '비숑', '프렌치 불독', '슈나우저', '시바이누', '골든리트리버', '사모예드', '웰시코기', '도베르만', '푸들', '닥스훈트', '비글', '허스키']

# 빈 데이터프레임 생성: '품종'과 '성격' 컬럼명만 있는 데이터프레임
blog_df = pd.DataFrame(columns=('Breed', 'Personality'))

for breed in dog_list:
    # 검색어: 품종+성격
    query = urllib.parse.quote(breed + ' 성격')

    # 출력 조건 설정
    idx = 0  # 여러 개의 정보를 받을 때 횟수 카운트용
    display = 100  # 100개 단위로 정보 받아오기
    start = 1  # 첫 번째 시작점
    end = 200  # 마지막 시작점 (200개 크롤링)

    breed_df = pd.DataFrame(columns=('Breed', 'Personality'))  # 현재 품종에 대한 데이터프레임 생성

    for start_index in range(start, end + 1, display):
        url = "https://openapi.naver.com/v1/search/blog?query=" + query \
              + '&display=' + str(display) \
              + '&start=' + str(start_index)

        request = urllib.request.Request(url)
        request.add_header("X-Naver-Client-Id", client_id)
        request.add_header("X-Naver-Client-Secret", client_secret)
        response = urllib.request.urlopen(request)
        rescode = response.getcode()

        if rescode == 200:  # API로부터 정상적인 응답을 받은 경우 (데이터 크롤링 성공)
            response_body = response.read()
            response_dict = json.loads(response_body.decode('utf-8'))
            items = response_dict['items']  # 원하는 정보가 담겨있는 사전

            for item_index in range(0, len(items)):
                remove_tag = re.compile('<.*?>')

                description = re.sub(remove_tag, '', items[item_index]['description'])
                # 데이터 정제(클리닝)
                description = re.sub(r'http\S+|www.\S+', '', description)  # 웹링크 제거
                description = re.sub(r'[^\w\s가-힣]', '', description)  # 불필요한 문장 부호, 이모티콘, 특수문자 제거
                description = re.sub(r'\s+', ' ', description)  # 공백 제거
                description = re.sub(r'광고|성인', '', description)  # 광고성 글 제거
                description = re.sub(r'\d+', '', description)  # 숫자 제거
                description = description.strip()  # 양쪽 공백 제거
                description = re.sub(r'[a-zA-Z]', '', description)  # 영어 제거
                breed_df.loc[idx] = [breed, description]
                idx += 1
        else:
            print("Error Code:" + rescode)

    # 현재 품종에 대한 데이터프레임을 기존 데이터프레임에 연결(concatenate)
    blog_df = pd.concat([blog_df, breed_df], ignore_index=True)

# 크롤링한 데이터가 담긴 데이터프레임 앞부분 출력
print(blog_df.head())

# 크롤링한 데이터가 담긴 데이터프레임 뒤부분 출력
print(blog_df.tail())

# 데이터프레임을 Excel 파일로 저장
blog_df.to_excel('data_dog_personality.xlsx', index=False)
# blog_df.to_excel('/content/drive/MyDrive/data_dog_personality.xlsx', index=False)  # Google Drive에 저장하기 (Google Drive를 먼저 마운트해야 함!)

!pip install konlpy
import nltk
nltk.download('punkt')
nltk.download('wordnet')

import re
import nltk
from nltk.corpus import wordnet
from sklearn.feature_extraction.text import TfidfVectorizer
from konlpy.tag import Kkma

def preprocess_text(text):
    # 토큰화
    tokens = nltk.word_tokenize(text)

    # 형태소 분석 및 품사 태깅
    kkma = Kkma()
    morphs = kkma.pos(text)
    adjectives = [word for word, tag in morphs if tag.startswith('VA') and not tag.startswith('VX')]

    # 어간 추출 및 원형 복원
    lemmatizer = nltk.WordNetLemmatizer()
    stemmed_words = [lemmatizer.lemmatize(word) for word in adjectives]

    # 불용어 처리
    stopwords = ['좋','많','없','흔하', '힘들','다르','별다르','괜찮','바르','민하','안되','어떻','그렇','나쁘','이렇','빠르','지나치', '드물', '놀랍', '저렇', '고맙', '이뿌', '걸맞', '푸르', '재밌', '수많', '못지않', '스럽', '알맞', '맛있', '긴하', '요렇', '실하', '모나', '뜸하', '뜻깊', '그지없', '고프', '비싸', '올바르', '부적절하', '그러하', '귀하', '멋있', '잘생기', '동그랗', '귀찮', '두껍', '두텁', '길하', '네모나', '벅차', '아프', '아쉽', '가늘',"어떠하", "멋지", "심하", "시리", "가볍", "기쁘", "똑같", "없다", "심하", "어렵", "안녕하"]

    # 품종과 성격을 저장할 딕셔너리
    breed_personalities = {}

    # 각 품종별로 성격 추출
    filtered_words = [word for word in stemmed_words if word not in stopwords]

    return filtered_words

# Excel 파일에서 데이터 불러오기
df = pd.read_excel('data_dog_personality.xlsx')

# 형태소 분석기 초기화
kkma = Kkma()

# TF-IDF 벡터화 객체 초기화
tfidf_vectorizer = TfidfVectorizer()

# 품종과 성격을 저장할 딕셔너리
breed_personalities = {}

# 각 품종별로 성격 추출
for breed in df['Breed'].unique():
    breed_df = df[df['Breed'] == breed]
    breed_personalities_list = []
    for description in breed_df['Personality']:
        if isinstance(description, str):
            adjectives = preprocess_text(description)
            breed_personalities_list.extend(adjectives)
    breed_personalities_counts = pd.Series(breed_personalities_list).value_counts()
    top_personalities = breed_personalities_counts.head(100).index.tolist()
    breed_personalities[breed] = top_personalities

# 품종과 성격을 합치기
merged_personalities = []
for breed, personality_list in breed_personalities.items():
    merged_personality = ', '.join(personality_list)
    merged_personalities.append(merged_personality)

# 데이터프레임 생성
df_merged_personality = pd.DataFrame({'Breed': list(breed_personalities.keys()), 'Personality': merged_personalities})
df_merged_personality

# TF-IDF 적용
tfidf_matrix = tfidf_vectorizer.fit_transform(df_merged_personality['Personality'])
feature_names = tfidf_vectorizer.get_feature_names_out()

# 유의미한 성격 특성 추출
significant_personalities = []
for idx, row in df_merged_personality.iterrows():
    breed = row['Breed']
    personality = row['Personality']
    tfidf_values = tfidf_matrix[idx].toarray()[0]
    significant_indices = tfidf_values.argsort()[:][::-1]
    significant_features = [feature_names[i] for i in significant_indices]
    significant_personalities.append(significant_features)

# 유의미한 성격 특성을 포함한 데이터프레임 생성
df_significant_personalities = pd.DataFrame({'Breed': list(breed_personalities.keys()), 'Significant Personality': significant_personalities})
print(df_significant_personalities)

tfidf_matrix = tfidf_vectorizer.fit_transform(df_merged_personality['Personality'])
feature_names = tfidf_vectorizer.get_feature_names_out()

# 유의미한 성격 특성 추출
significant_personalities = []
for idx, row in df_merged_personality.iterrows():
    breed = row['Breed']
    personality = row['Personality']
    tfidf_values = tfidf_matrix[idx].toarray()[0]
    significant_indices = tfidf_values.argsort()[:][::-1]
    significant_features = [(feature_names[i], tfidf_values[i]) for i in significant_indices]
    significant_personalities.append(significant_features)

# 유의미한 성격 특성을 포함한 데이터프레임 생성
df_significant_personalities = pd.DataFrame({'Breed': list(breed_personalities.keys()), 'Significant Personality': significant_personalities})

print(df_significant_personalities)

df_significant_personalities.to_excel('df_significant_personalities.xlsx', index=False)

additional_keywords = {
    '교감능력(C)': ['달르','선하', '살갑', '우습', '친하', '슬프', '부드럽', '둔하', '무디'],
    '본능(W)': ['문제없','버겁','사기왕성하', '드세', '급하', '개구지','어리','사납','재빠르','앙칼지','옹골지','쌀쌀맞','무덥'],
    '의존(T)': ['깜찍하','서투르', '똑같', '편하', '가깝', '따르','다름없'],
    '필요(N)': ['궁금하','필요없', '쿨하', '쾌하','독하','끈질기','드세','험상궂','더럽'],
    '외향적(E)': ['우렁차', '해맑', '반갑', '활기차'],
    '내향적(I)': ['어질','날카롭', '약하', '얌전한', '낮설','부끄럽','조그맣'],
    '모험(A)': ['거침없','끈질기','당차', '다부지', '거칠','궁금하','누렇','인상깊','반갑'],
    '안주(L)': ['기다랗','과하','어둡','문제없','까다롭','뒤늦','귀찮', '뚱하', '점잖', '게으르','무덥']
}

tfidf_matrix = tfidf_vectorizer.fit_transform(df_merged_personality['Personality'])
feature_names = tfidf_vectorizer.get_feature_names_out()

# 세분화된 키워드를 포함한 개수 및 중요도 계산
breed_keyword_counts = {}
for breed, personality_keywords in zip(df_significant_personalities['Breed'], df_significant_personalities['Significant Personality']):
    breed_keyword_counts[breed] = {keyword: 0 for keyword in additional_keywords}
    for keyword, sub_keywords in additional_keywords.items():
        count = sum(keyword in [kw[0] for kw in personality_keywords[:25]] for keyword in sub_keywords)
        tfidf_score = sum(kw[1] for kw in personality_keywords[:25] if kw[0] in sub_keywords)
        breed_keyword_counts[breed][keyword] = count + tfidf_score

# 결과를 데이터프레임으로 변환
result_df = pd.DataFrame(breed_keyword_counts).T
result_df = result_df.reset_index().rename(columns={"index": "Breed"})

print(result_df)

# Creating the DBTI for each breed group
dbti = {}

for breed in result_df['Breed']:
    scores_cw = result_df.loc[result_df['Breed'] == breed, ['교감능력(C)', '본능(W)']].values[0]
    scores_tn = result_df.loc[result_df['Breed'] == breed, ['의존(T)', '필요(N)']].values[0]
    scores_ei = result_df.loc[result_df['Breed'] == breed, ['외향적(E)', '내향적(I)']].values[0]
    scores_al = result_df.loc[result_df['Breed'] == breed, ['모험(A)', '안주(L)']].values[0]

    max_score_cw = max(scores_cw)
    max_score_tn = max(scores_tn)
    max_score_ei = max(scores_ei)
    max_score_al = max(scores_al)

    dbti_breed = ''
    if max_score_cw == scores_cw[0]:
        dbti_breed += 'C'
    else:
        dbti_breed += 'W'

    if max_score_tn == scores_tn[0]:
        dbti_breed += 'T'
    else:
        dbti_breed += 'N'

    if max_score_ei == scores_ei[0]:
        dbti_breed += 'E'
    else:
        dbti_breed += 'I'

    if max_score_al == scores_al[0]:
        dbti_breed += 'A'
    else:
        dbti_breed += 'L'

    if breed in dbti:
        dbti[breed].append(dbti_breed)
    else:
        dbti[breed] = [dbti_breed]

# Creating the DBTI DataFrame
dbti_df = pd.DataFrame({'Breed': list(dbti.keys()), 'DBTI': [''.join(dbti[breed]) for breed in dbti.keys()]})

# Printing the result
print(dbti_df)

answers = []  # 답변을 저장할 리스트
print("="*79)
print("예비 반려인님 반갑습니다! ▼・ᴥ・▼\n 본 서비스를 통해 당신에게 적합한 반려견을 추천해드립니다.\n 반려견과 함께하는 모습을 떠올려보며 아래 질문들에 대해 “a” 혹은 “b”로 답변해주세요.\n \n 그럼 시작합니다! ໒(＾ᴥ＾)७")
print("|\\_/|");
print("|q p|   /}");
print("( 0 )\"\"\"\\");
print("|\"^\"`    |");
print("||_/=\\\\__|");
print("="*79)


# 질문 1
question_1 = "1. 강아지에게 새로운 장난감을 들고 온 당신 반려견에게 어떤 반응을 기대하시나요?\n a. 너무 신난다멍! 원래 가지고 놀던 장난감 친구들에게 소개해줘야겠다멍! \n b. 원래 알던 장난감이 아니다멍! 그치만 고맙다멍!\n"
answer = input(question_1).upper()
if answer == 'A':
    answers.append('C')
else:
    answers.append('W')
print("-"*79)
# 질문 2
question_2 = "2. 집에 낯선 손님이 온 상황, 반려견의 어떤 반응을 원하시나요?\n a. (손님에게 달려가며) 누구냐멍!\n b. (집사에게 달려오며) 누가 왔다멍!\n"
answer = input(question_2).upper()
if answer == 'A':
    answers.append('T')
else:
    answers.append('N')
print("-"*79)
# 질문 3
question_3 = "3. 한가로운 주말, 반려견의 어떤 반응을 원하시나요?\n a. 산책하러 나가자멍! 난 집 밖에 나가서 친구들을 보고싶다멍\n b. 오랜만의 주말, 집에서 쉬자멍!\n"
answer = input(question_3).upper()
if answer == 'A':
    answers.append('E')
else:
    answers.append('I')
print("-"*79)
# 질문 4
question_4 = "4. 반려견과 산책 중 새로운 길을 만난 당신, 반려견의 어떤 반응을 원하시나요? \n a. 오히려 좋아! 여기로 가보자멍! \n b. 이 쪽이 아니다멍! 집은 이쪽 방향이다멍! \n"
answer = input(question_4).upper()
if answer == 'A':
    answers.append('A')
else:
    answers.append('L')
print("="*79)
# DBTI 결과를 계산합니다.
dbti_result = ''.join(answers)

# 결과를 출력합니다.
print("당신의 DBTI 유형은:", dbti_result)


# 관계형 외향/내향 - E/I
# 야생성 교감/본능 - C/W
# 의존성 신뢰/필요 - T/N
# 활동성 모험/안주 - A/L


# Dictionary of nicknames
nicknames = {
    'WTIL': '껌딱지형',
    'WTIA': '관찰자형',
    'WNIA': '야생견형',
    'WNIL': '안정추구형',
    'WTEL': '개구쟁이형',
    'WTEA': '호기심쟁이',
    'WNEA': '동네 대장형',
    'WNEL': '지킬 앤 하이드형',
    'CTEL': '반려특화형',
    'CTEA': '만능엔터테이너형',
    'CNEA': '핵인싸형',
    'CNEL': '막내둥이형',
    'CTIA': '모범생형',
    'CTIL': '엄친아형',
    'CNIA': '나 혼자 산다형',
    'CNIL': '밀당천재형'
}

# Finding breeds with matching DBTI
matching_breeds = dbti_df.loc[dbti_df['DBTI'] == dbti_result, 'Breed']

# Checking if matching breeds exist
if len(matching_breeds) > 0:
    breed = matching_breeds.iloc[0]
    nickname = nicknames[dbti_result]
    message = f"{nickname}형인 당신!\n 당신과 유사한 성격을 가진 반려견 종으로 [{breed}] 추천드립니다!"
else:
    message = "일치하는 품종이 없습니다."

# Printing the message
print(message)
print("="*79)
if dbti_result == 'WTIL':
  print("푸들은 어떤 댕댕이냐면요? \n 반려인에 대한 믿음이 강해 함께 있는 시간을 즐거워해요. \n 소심한 성격을 가지고 있어 너무 적극적으로 다가오는 친구에게는 조금 경계할 수도 있어요.")
  print("푸들을 키울 때, 이렇게 해보는 건 어떨까요? \n 천둥번개 등 갑작스러운 상황에 놀라지 않게 해주세요. \n 예민한 성격을 가지고 있으므로 다양한 자극상황에 긍정적인 경험을 할 수 있도록 해주세요.")

elif dbti_result == 'WTIA':
  print("프렌치 불독은 어떤 댕댕이냐면요? \n 자신의 안전을 확인하기 위해 꾸준히 주변을 관찰하는 편이에요. \n 관찰을 잘해 교육이나 훈련에 대한 학습 능력이 좋은 편이에요.")
  print("프렌치 불독을 키울 때, 이렇게 해보는 건 어떨까요? \n 낯선 환경에 적응하는 시간이 필요해요. \n 미용이나 목욕 등에 스트레스를 받을 수 있으니 보상을 이용해 좋은 기억부터 만들어주세요.")

elif dbti_result == 'WNIA':
  print("치와와는 어떤 댕댕이냐면요? \n 독립적인 편이라 분리불안의 정도가 덜한 편이에요. \n 새로운 환경에 대한 호기심과 적응능력이 좋은 편이에.")
  print("치와와를 키울 때, 이렇게 해보는 건 어떨까요? \n 산책을 할 때 다른 강아지들에게 다소 공격적인 모습을 보일 수 있으니 목줄을 꼭 차주세요. \n 사회화를 목적으로 다른 강아지와의 접촉을 강제하지는 마세요.")

elif dbti_result == 'WNIL':
  print("허스키는 어떤 댕댕이냐면요? \n 낯선 것들 보다는 안정을 추구하는 편이에요. \n 보호자에게 신뢰가 쌓이면 무한한 사랑을 주는 편이에요.")
  print("허스키를 키울 때, 이렇게 해보는 건 어떨까요? \n 반려견이 낯선 환경을 맞이하기 전 따듯하게 5분 정도 안아주세요. \n 불규칙적인 것에 스트레스를 받을 수 있으니 규칙적인 생활 루틴을 만들어 주세요.")

elif dbti_result == 'WTEL':
  print("시바이누는 어떤 댕댕이냐면요? \n 보호자에게 관심 받는 것을 즐기는 편이에요. \n 신뢰관계가 형성되지 않은 낯선 곳으로의 노출은 아이를 힘들게 해요.")
  print("시바이누를 키울 때, 이렇게 해보는 건 어떨까요? \n 흥분하며 다가가기 보다는 차분하게 반려견을 대해주세요. \n 노즈워크를 통해 아이의 성취감과 자신감을 높여주세요.")

elif dbti_result == 'WTEA':
  print("진돗개는 어떤 댕댕이냐면요? \n 어느 곳이라도 두려움 없이 호기심을 가지고 다가가는 편이에요. \n 새로운 환경을 좋아해 종종 흥분하는 경우가 있어요.")
  print("진돗개를 키울 때, 이렇게 해보는 건 어떨까요? \n 반려견의 행동을 제한하기 보다는 자유를 보장해주세요. \n 참을성을 기르는 법, 차분히 기다리는 법에 대한 교육이 특별히 필요해요.")

elif dbti_result == 'WNEA':
  print("슈나우저는 어떤 댕댕이냐면요? \n 산책 시 마킹이나 노즈워크 등 본능적인 욕구를 충족하기 위해 주도적으로 움직여요. \n 스스로의 규칙을 만들어 그대로 행동하려는 스타일이에요.")
  print("슈나우저를 키울 때, 이렇게 해보는 건 어떨까요? \n 자신감이 너무 넘쳐 공격성을 보이기도 하니, 리드줄을 너무 길게 하고 다니지 마세요. \n 주도권 훈련(오비디언스)가 꾸준히 필요해요.")

elif dbti_result == 'WNEL':
  print("닥스훈트는 어떤 댕댕이냐면요? \n 보호자와 함께라면 활발하고 주도적인 성향을 보이는 편이에요. \n 반려견 유치원이나 미용실 등 시설에 얌전하고 차분하게 잘 적응하는 편이에요.")
  print("닥스훈트를 키울 때, 이렇게 해보는 건 어떨까요? \n 호불호가 강하고 고집이 센 편이니 낯선 사람의 손길을 주의하세요. \n 엎드려와 같은 훈련을 통해 차분히 기다리는 법에 대해 특별히 교육해주세요.")

elif dbti_result == "CTEL":
  print("비숑은 어떤 댕댕이냐면요? \n 사람과 강아지 모두를 좋아해 낯선 대상에게도 친근히 다가가는 편이에요. \n 모든 상황에 대해 긍정적으로 받아들이고 주변에 안정감을 주곤 해요.")
  print("비숑을 키울 때, 이렇게 해보는 건 어떨까요? \n 무작정 다른 강아지들에게 소개해주다 공격을 받으면 트라우마가 생길 수 있으니 유의해주세요. \n 스트레스를 받고 티를 내지 않을 뿐 참고 있는 경우도 잦으니 세심히 관찰해주세요.")

elif dbti_result == "CNEA":
  print("웰시코기는 어떤 댕댕이냐면요? \n 활발한 성격으로 다른 강아지나 사람들에게 들이대고 보는 편이에요. \n 다른 강아지의 시그널을 잘 이해하는 편으로 상대 강아지가 싫어하면 거리를 잘 지켜요.")
  print("웰시코기를 키울 때, 이렇게 해보는 건 어떨까요? \n 외부에 대한 호기심이 많은 편으로 콜백훈련을 특별히 교육해주세요. \n 터그 놀이, 산책 등으로 충분히 에너지를 소비할 수 있도록 해주세요.")

elif dbti_result == "CNEL":
  print("말티즈는 어떤 댕댕이냐면요? \n 애교가 많고 보호자에 대한 관심이 높은 편이에요. \n 성격이 차분하고 온순하여 주변 강아지들에게 헬퍼독 역할을 할 수도 있어요.")
  print("말티즈를 키울 때, 이렇게 해보는 건 어떨까요? \n 너무 강압적이거나 단호한 모습을 보여주지 마세요. \n 과잉보호는 요구성 행동을 하며 떼를 쓸 수 있으니 특별히 주의하세요.")

elif dbti_result == "CTIA":
  print("도베르만은 어떤 댕댕이냐면요? \n 보호자와 함께 놀이를 하며 교감하고 싶어하는 편이에요. \n 새로운 학습에 대한 습득 능력이 뛰어나요.")
  print("도베르만을 키울 때, 이렇게 해보는 건 어떨까요? \n 적극적인 사람이나 강아지들에게 종종 공격성을 보이는 경우가 있으니 유의하세요. \n 힐 트레이닝(각측보행)을 통해 사후 통제를 위한 예방 교육을 하세요.")

elif dbti_result == "CTIL":
  print("시츄는 어떤 댕댕이냐면요? \n 차분한 성격에 배려심이 좋아 타견과 트러블을 일으킬 가능성이 낮은 편이에요. \n 보호자와 교감 능력이 매우 뛰어나고 학습 능력이 좋은 편이에요.")
  print("시츄를 키울 때, 이렇게 해보는 건 어떨까요? \n 보호자에게 의존 정도가 강한 편이니 요구성 행동에 단호하게 반응해주세요.\n 착한 만큼 상처도 쉽게 받을 수 있으므로 세심한 관찰이 필요해요.")

elif dbti_result == "CNIA":
  print("사모예드는 어떤 댕댕이냐면요? \n 환경적응력이 높고 독립성이 강해 낯선 환경에서 혼자서도 두려움 없이 잘 지내는 편이에요. \n 새로운 환경에 대한 호기심도 많지만, 정작 타견들에게는 큰 관심을 보이진 않아요.")
  print("사모예드를 키울 때, 이렇게 해보는 건 어떨까요? \n 자신에게 피해가 오면 공격으로 맞받아치는 성격이므로 리콜 교육을 특별히 해주세요. \n 혼자 노는 것을 마냥 좋아하진 않으니 보호자와의 교감을 충분히 해주세요.")

elif dbti_result == "CNIL":
  print("비글은 어떤 댕댕이냐면요 \n 잘 맞는 친구와 노는 것도 좋아하지만 독립적인 성향이 있어 혼자 노는 것을 더 좋아해요. \n 기본적으로 사람에게 큰 관심이 없는 편이지만, 간식이 있는 사람에게는 애교를 보이기도 해요.")
  print("비글을 키울 때, 이렇게 해보는 건 어떨까요? \n 혼자 놀고 있는 것을 즐겨하는 편이니 다른 강아지와의 접촉을 강제하지 마세요. \n 아이를 억지로 곁에 두고 귀찮게 하지 말고 휴식시간을 반드시 보장해주세요.")

print("="*79)
print("반려견을 키우기 위해서는 책임감이 필요하기에 신중한 고민이 필요합니다.")
print("본 서비스를 통해 반려견과 보다 행복한 견생을 할 수 있길 바랍니다. ▼･ｪ･▼ﾉ”")